# 정렬

### 카운팅 정렬 (Counting Sort)
---
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 제한 사항
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
- 시간 복잡도 : O(n + k)  - n은 리스트의 길이, k는 정수의 최대값
- [0, 4, 1, 3, 1, 2, 4, 1]정렬 과정
    - Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.
        - counts[i] : i의 발생 회수
    - 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다. (누적합)
    - counts[1]을 감소시키고 Temp에 1을 삽입한다
    - counts[4]를 감소시키고 Temp에 4를 삽입한다
    - counts[2]를 감소시키고 Temp에 2를 삽입한다
    - counts[1]을 감소시키고 Temp에 1을 삽입한다
    - counts[3]을 감소시키고 Temp에 3을 삽입한다
    - counts[1]을 감소시키고 Temp에 1을 삽입한다
    - counts[4]를 감소시키고 Temp에 4를 삽입한다
    - counts[0]를 감소시키고 Temp에 0을 삽입한다
    - 정렬 완료
- 단점 : n이 비교적 작을 때만 가능하다

```python
def Counting_Sort(A, B, k):
    # A[] -- 입력배열(0 to k)
    # B[] -- 정렬된 배열
    # C[] -- 카운트 배열

    C = [0] * (k+1)

    for i in range(0, len(A)):
        C[A[i]] += 1
    
    for i in range(1, len(C)):
        C[i] += C[i-1]
    
    for i in range(len(B)-1, -1, -1):
        C[A[i]] -= 1
        B[C[A[i]]] = A[i]
```
```python
data = [4, 7, 1, 3, 7, 5, 1, 26, 18, 13, 0, 4, 13, 4, 18, 13]
counts = [0]

for i in data:
    l = len(counts)
    if l - 1 < i:
        pl = i - l + 1
        counts += [0] * pl
    counts[i] += 1

for j in range(1, len(counts)):
    counts[j] = counts[j - 1] + counts[j]

temp = [0] * len(data)
for k in range(len(data)-1, -1, -1):
    idx = data[k]
    b = counts[idx]
    temp[b - 1] = idx

print(*temp)
```
# 순열
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개중 r개를 택하는 순열은 아래와 같이 표현한다.
$$nPr$$
- 그리고 nPr은 다음과 같은 식이 성립한다.
$$nPr = n * (n - 1) * (n - 2)* ...*(n - r + 1)$$
- [1, 2, 3]을 포함하는 모든 순열을 생성하는 함수
```python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```
# 탐욕(Greedy) 알고리즘
- 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.
- 동작 과정
    1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해집합(Solution Set)에 추가한다.
    2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
    3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.